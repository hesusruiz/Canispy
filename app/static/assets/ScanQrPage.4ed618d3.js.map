{"version":3,"file":"ScanQrPage.4ed618d3.js","sources":["../../src/pages/ScanQrPage.js"],"sourcesContent":["import { log } from '../log'\r\nimport { AbstractPage, register, html, gotoPage } from '../components/AbstractPage'\r\nimport { getPreferredVideoDevice, getPlatformOS } from '../components/camerainfo'\r\n\r\n\r\n// This is to facilitate debugging of certificates\r\nvar testQRdata = \"HC1:NC\"\r\n\r\nvar testQR = {\r\n    text: testQRdata\r\n}\r\n\r\n// Set the QR raw data above and enable debugging setting this flag to true\r\nvar debugging = false\r\n\r\nconst QR_UNKNOWN = 0\r\nconst QR_URL = 1\r\nconst QR_MULTI = 2\r\nconst QR_HC1 = 3\r\n\r\n\r\nregister(\"ScanQrPage\", class ScanQrPage extends AbstractPage {\r\n    displayPage                 // The page name used to display the HC1 QR code\r\n    detectionInterval = 200     // Milliseconds between attempts to decode QR\r\n    videoElement = {}           // DOMElement where the video is displayed, reused across invocations\r\n    nativeBarcodeDetector       // Instance of the native barcode detector object\r\n    zxingReader                 // Barcode detector in JavaScript\r\n    lastUsedCameraId            // The last used camera ID\r\n    canvasElement\r\n    canvasSpace\r\n\r\n    constructor(id) {\r\n    \r\n        super(id);\r\n\r\n        // Check if native barcode detection is supported\r\n        if (!('BarcodeDetector' in window)) {\r\n            console.log('Barcode Detector is not supported by this browser.')\r\n\r\n            // Native support not available, import the ZXING javascript library\r\n            this.zxingPromise = import('@zxing/browser')\r\n        } else {\r\n            console.log('Barcode Detector supported!');\r\n\r\n            // create new detector\r\n            this.nativeBarcodeDetector = new BarcodeDetector({ formats: ['qr_code'] });\r\n        }\r\n\r\n        this.videoElement = {}\r\n        this.canvasElement = document.createElement('canvas')\r\n        this.canvasSpace = this.canvasElement.getContext(\"2d\")\r\n\r\n    }\r\n\r\n    async enter(displayPage) {\r\n\r\n        // displayPage is the page that should display the scanned QR\r\n        // If not specified, we default to the DisplayHcert page\r\n        if (!displayPage) {\r\n            displayPage = \"DisplayHcert\"\r\n        }\r\n        this.displayPage = displayPage\r\n\r\n        // If debugging, just try to decode the test QR\r\n        if (debugging) {\r\n            await this.processQRpiece(testQR, displayPage)\r\n            return\r\n        }\r\n\r\n        if (!this.nativeBarcodeDetector) {\r\n            let zxing = await this.zxingPromise\r\n            this.zxingReader = new zxing.BrowserQRCodeReader()\r\n        }\r\n\r\n        // Select the camera and store locally for later uses\r\n        this.lastUsedCameraId = await this.selectCamera()\r\n\r\n        // Display the screen with the video element\r\n        // The 'ref' in the template will set the 'current' property in the specified object\r\n        // to the video DOM element. In this case, the video DOM element can be accessed later at\r\n        // this.videoElement.current\r\n        let theHtml = html`\r\n        <video ref=${this.videoElement} oncanPlay=${()=>this.canPlay()}></video>\r\n        `;\r\n        this.render(theHtml)\r\n\r\n        let constraints;\r\n        if (!this.lastUsedCameraId) {\r\n            console.log(\"Constraints without camera\")\r\n            constraints = {\r\n                audio: false,\r\n                video: {\r\n                    // width: { ideal: 1080, max: 1920 },\r\n                    facingMode: \"environment\"\r\n                }\r\n            }\r\n        } else {\r\n            console.log(\"Constraints with deviceID:\", this.lastUsedCameraId)\r\n            constraints = {\r\n                audio: false,\r\n                video: {\r\n                    // width: { ideal: 1080, max: 1920 },\r\n                    deviceId: this.lastUsedCameraId\r\n                }\r\n            }\r\n        }\r\n\r\n        let stream;\r\n        try {\r\n            // Request a stream which forces the system to ask the user\r\n            stream = await navigator.mediaDevices.getUserMedia(constraints);\r\n            let videoTracks = stream.getVideoTracks()\r\n            for (let i = 0; i < videoTracks.length; i++) {\r\n                let caps = videoTracks[i].getCapabilities()\r\n                console.log(caps)\r\n            }\r\n\r\n            // Assign the camera stream to the video element in the page\r\n            // Eventually, the event 'canPlay' will be fired signallig video is ready to be displayed\r\n            this.videoElement.current.setAttribute('autoplay', 'true');\r\n            this.videoElement.current.setAttribute('muted', 'true');\r\n            this.videoElement.current.setAttribute('playsinline', 'true');\r\n            this.videoElement.current.srcObject = stream\r\n            console.log(stream)\r\n\r\n        } catch (error) {\r\n            log.error(\"Error getting stream\", error)\r\n            this.render(this.messageErrorGettingStream())\r\n            return;\r\n        }\r\n\r\n    }\r\n\r\n    async selectCamera() {\r\n\r\n        // Try to use the camera explicitly configured by the user\r\n        var selectedCameraId = localStorage.getItem(\"selectedCamera\")\r\n        console.log(\"User selected camera:\", selectedCameraId)\r\n\r\n        // If nothing configured, try to use last one used, if any\r\n        if (!selectedCameraId) {\r\n            selectedCameraId = this.lastUsedCameraId\r\n            console.log(\"Last used camera:\", selectedCameraId)\r\n        }\r\n\r\n        // Some Android phones have a problem selecting automatically the best camera for scanning (eg. some Samsung)\r\n        // If we are in Android and this is the first time, try to select the most appropriate camera\r\n        // This will request permission from the user\r\n        if (!selectedCameraId && (\"Android\" == getPlatformOS())) {\r\n            console.log(\"We are in Andoid and this is the first time\")\r\n            let allVideoDevices;\r\n            try {\r\n                allVideoDevices = await getPreferredVideoDevice()\r\n                console.log(\"Video devices in Android:\", allVideoDevices)\r\n            } catch (error) {\r\n                log.error(\"Error requesting camera access\", error)\r\n            }\r\n            if (allVideoDevices && allVideoDevices.defaultPreferredCamera) {\r\n                selectedCameraId = allVideoDevices.defaultPreferredCamera.deviceId\r\n                console.log(\"Selected camera in Android:\", selectedCameraId)\r\n            }\r\n\r\n            if (!selectedCameraId) {\r\n                console.log(\"In Android and no selected camera\")\r\n            }\r\n\r\n        }\r\n\r\n        return selectedCameraId;\r\n\r\n    }\r\n\r\n    async canPlay() {\r\n        console.log(\"Video can play, try to detect QR\")\r\n        // The video stream is ready, show the 'video' element\r\n        this.videoElement.current.style.display = \"block\"\r\n\r\n        // Start playing the video from the camera\r\n        this.videoElement.current.play()\r\n\r\n        // Start the detector of QR codes directly in the video element\r\n        this.detectCode()\r\n\r\n    }\r\n\r\n    // Detect code function \r\n    async detectCode() {\r\n\r\n        let qrType = QR_UNKNOWN\r\n        let qrData\r\n\r\n        // Detect QR codes in the video element\r\n        if (this.nativeBarcodeDetector) {\r\n            // Native BarcodeDetector is available\r\n\r\n            let codes\r\n            try {\r\n                codes = await this.nativeBarcodeDetector.detect(this.videoElement.current)\r\n            } catch (error) {\r\n                // Log an error if one happens\r\n                log.error(err);\r\n                return;\r\n            }\r\n    \r\n            // If not detected, try again\r\n            if (codes.length === 0) {\r\n                setTimeout(() => this.detectCode(), this.detectionInterval)\r\n                return;\r\n            }\r\n    \r\n            // There may be several QR codes detected\r\n            // We will process the first one that is recognized\r\n            for (const barcode of codes) {\r\n                // Log the barcode to the console\r\n                console.log(barcode)\r\n                qrData = barcode.rawValue\r\n                qrType = this.detectQRtype(qrData)\r\n                if (qrType != QR_UNKNOWN) {\r\n                    // Exit from the loop as soon as we recognize a QR type\r\n                    break;\r\n                }\r\n            }\r\n    \r\n        } else {\r\n            // Native support not available, use the javascript library\r\n\r\n            try {\r\n                const result = await this.zxingReader.decodeOnceFromVideoElement(this.videoElement.current);     \r\n                qrData = result.text\r\n                console.log(\"RESULT\", qrData)\r\n            } catch (error) {\r\n                log.error(\"ZXING decoding error\", error)\r\n            }\r\n            \r\n            qrType = this.detectQRtype(qrData)\r\n\r\n        }\r\n\r\n        // If no QR code recognized, keep trying\r\n        if (qrType === QR_UNKNOWN) {\r\n            setTimeout(() => this.detectCode(), this.detectionInterval)\r\n            return;\r\n        }\r\n\r\n        // Handle HCERT data\r\n        if (qrType === QR_HC1) {\r\n            console.log(\"Going to \", this.displayPage)\r\n            gotoPage(this.displayPage, qrData)\r\n            return true;\r\n        }\r\n\r\n    }\r\n\r\n    async exit() {\r\n\r\n        if (!this.videoElement.current) {\r\n            return;\r\n        }\r\n\r\n        // Reset the decoder just in case the camera was still working\r\n        this.videoElement.current.style.display = \"none\"\r\n\r\n        // Release resources\r\n        if (this.videoElement.current.srcObject !== undefined) {\r\n            this.videoElement.current.srcObject.getVideoTracks().forEach((track) => {\r\n                track.stop();\r\n            });\r\n        }\r\n\r\n    }\r\n\r\n    // Try to detect the type of data received\r\n    detectQRtype(qrData) {\r\n\r\n        if (!qrData || !qrData.startsWith) {\r\n            log.error(\"detectQRtype: data is not string\")\r\n            return QR_UNKNOWN;\r\n        }\r\n\r\n        if (qrData.startsWith(\"HC1:\")) {\r\n            return QR_HC1;\r\n        } else if (qrData.startsWith(\"multi|w3cvc|\")) {\r\n            // A multi-piece JWT\r\n            return QR_MULTI;\r\n        } else if (qrData.startsWith(\"https\")) {\r\n            // Normal QR with a URL where the real data is located\r\n            // We require secure connections with https\r\n            return QR_URL;\r\n        } else {\r\n            return QR_UNKNOWN\r\n        }\r\n    }\r\n\r\n    errorMessage(title, message) {\r\n\r\n        let theHtml = html`\r\n        <div class=\"container\">\r\n            <div class=\"w3-card-4 center\" style=\"margin-top:100px;\">\r\n        \r\n                <header class=\"container color-primary\" style=\"padding:10px\">\r\n                    <h1>${title}</h1>\r\n                </header>\r\n        \r\n                <div class=\"container ptb-16\">\r\n                    <p>${message}</p>\r\n                    <p>${T(\"Please click Accept to refresh the page.\")}</p>\r\n                </div>\r\n        \r\n                <div class=\"ptb-16\">\r\n        \r\n                    <button class=\"btn-primary\" @click=${()=> window.location.reload()}>${T(\"Accept\")}</button>\r\n        \r\n                </div>\r\n        \r\n            </div>\r\n        </div>\r\n        `\r\n        return theHtml\r\n\r\n    }\r\n\r\n    messageErrorGettingStream() {\r\n\r\n        let theHtml = html`\r\n        <div class=\"container\">\r\n            <div class=\"w3-card-4 center\" style=\"margin-top:100px;\">\r\n        \r\n                <header class=\"container color-primary\" style=\"padding:10px\">\r\n                    <h1>${T(\"Error getting video stream\")}</h1>\r\n                </header>\r\n        \r\n                <div class=\"container ptb-16\">\r\n                    <p>${T(\"There was an error trying to start the camera.\")}</p>\r\n                    <p>${T(\"Please click Accept to refresh the page.\")}</p>\r\n                </div>\r\n        \r\n                <div class=\"ptb-16\">\r\n        \r\n                    <button class=\"btn-primary\" @click=${()=> window.location.reload()}>${T(\"Accept\")}</button>\r\n        \r\n                </div>\r\n        \r\n            </div>\r\n        </div>\r\n        `\r\n        return theHtml\r\n\r\n    }\r\n\r\n    messageNoCameraPermissions() {\r\n\r\n        let theHtml = html`\r\n        <div class=\"container\">\r\n            <div class=\"w3-card-4 center\" style=\"margin-top:100px;\">\r\n        \r\n                <header class=\"container color-primary\" style=\"padding:10px\">\r\n                    <h1>${T(\"No camera access\")}</h1>\r\n                </header>\r\n        \r\n                <div class=\"container ptb-16\">\r\n                    <p>${T(\"You need to allow camera access to be able to scan a QR.\")}</p>\r\n                    <p>${T(\"Please click Accept to refresh the page.\")}</p>\r\n                </div>\r\n        \r\n                <div class=\"ptb-16\">\r\n        \r\n                    <button class=\"btn-primary\" @click=${()=> window.location.reload()}>${T(\"Accept\")}</button>\r\n        \r\n                </div>\r\n        \r\n            </div>\r\n        </div>\r\n        `\r\n        return theHtml\r\n\r\n    }\r\n\r\n})\r\n\r\n\r\n\r\n\r\n// This is the state object used by the background animation routine.\r\n// Its values are set by the QR scanning initialization routine\r\nvar qrScan = {\r\n    // The page that has invoked the scan\r\n    callerPage: \"\",\r\n\r\n    // The HTML element where the video frames will be placed for analysis\r\n    canvasElement: \"\",\r\n\r\n    // The canvas context with image data\r\n    canvas: \"\",\r\n\r\n    // The element in the page to display messages about status of scanning\r\n    progressMessages: \"\",\r\n\r\n    // The page where thee coded QR will be displayed\r\n    displayQRPage: \"\",\r\n\r\n    // Page that initiated the scanning\r\n    callerType: \"\",\r\n\r\n    // To build the whole JWT from the received pieces\r\n    receivedQRPieces: [],\r\n    receivedPieces: \"\",\r\n\r\n    // The HTML element where the video stream is going to be placed\r\n    video: \"\",\r\n\r\n    // The video stream object\r\n    myStream: \"\",\r\n};\r\n\r\n// Start the camera to scan the QR\r\n// The scan can be used either by the Passenger or the Verifier\r\nexport async function initiateReceiveQRScanning(\r\n    _canvasElement,\r\n    _qrMessageElement,\r\n    _displayQRPage,\r\n    _callerType\r\n) {\r\n    // _canvasElement: DOM element where the images will be displayed\r\n    // _qrMessageElement: DOM element to display info messages\r\n    // _displayQRPage: page to switch to display contents of the QR\r\n    // _callerType: who is calling, to customise the display of the QR\r\n\r\n\r\n    // Get the current page where scanning is started\r\n    var currentPage = \"\";\r\n    if (window.history.state != null) {\r\n        currentPage = window.history.state.pageName;\r\n    }\r\n    qrScan[\"callerPage\"] = currentPage;\r\n\r\n    // The HTML element where the video frames will be placed for analysis\r\n    qrScan[\"canvasElement\"] = _canvasElement;\r\n\r\n    // Save in global variable the element to display messages about progress of scanning\r\n    qrScan[\"progressMessages\"] = _qrMessageElement;\r\n\r\n    // Save the input parameters in global variables to keep state across timer ticks\r\n    qrScan[\"displayQRPage\"] = _displayQRPage;\r\n\r\n    // Save the input parameters in global variables to keep state across timer ticks\r\n    qrScan[\"callerType\"] = _callerType;\r\n\r\n    // Reset the variables holding the received pieces\r\n    qrScan[\"receivedQRPieces\"] = [];\r\n    qrScan[\"receivedPieces\"] = new Set();\r\n\r\n    // Get the canvas context with image data and store in global variable\r\n    qrScan[\"canvas\"] = qrScan[\"canvasElement\"].getContext(\"2d\");\r\n\r\n    // Create the HTML element to place the video stream and save in global variable\r\n    qrScan[\"video\"] = document.createElement(\"video\");\r\n    //  let elwidth = Math.min(screen.availWidth - 50, 450);\r\n    //  qrScan[\"video\"].style.width = document.querySelector(\"#passengerQRScanPage .container\").clientWidth + \"px\"\r\n\r\n    // Make sure that the canvas element is hidden for the moment\r\n    qrScan[\"canvasElement\"].hidden = true;\r\n\r\n    // Display a message while we have not detected anything\r\n    qrScan[\"progressMessages\"].innerText = \"Waiting for QR .........\";\r\n\r\n    // Request permission from user to get the video stream\r\n    // Use \"facingMode: environment\" to attempt to get the main camera on phones\r\n    navigator.mediaDevices\r\n        .getUserMedia({ video: { facingMode: \"environment\" } })\r\n        .then(function (stream) {\r\n            // Store the stream in global variable for later\r\n            qrScan[\"myStream\"] = stream;\r\n\r\n            // Connect the video stream to the \"video\" element in the page\r\n            qrScan[\"video\"].srcObject = stream;\r\n            qrScan[\"video\"].setAttribute(\"playsinline\", true); // required to tell iOS safari we don't want fullscreen\r\n            qrScan[\"video\"].play();\r\n\r\n            // Call the \"tick\" function on the next animation interval\r\n            //      setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n            requestAnimationFrame(ReceiveQRtick);\r\n        });\r\n}\r\n\r\n// This function is called periodically until we get a result from the scan\r\n// We use global variables to know the context on which it was called\r\nasync function ReceiveQRtick() {\r\n    try {\r\n        // Load variables for easier referencing\r\n        var video = qrScan[\"video\"];\r\n        var canvas = qrScan[\"canvas\"];\r\n        var canvasElement = qrScan[\"canvasElement\"];\r\n        var receivedPieces = qrScan[\"receivedPieces\"];\r\n        var receivedQRPieces = qrScan[\"receivedQRPieces\"];\r\n        var progressMessages = qrScan[\"progressMessages\"];\r\n        var myStream = qrScan[\"myStream\"];\r\n        var callerType = qrScan[\"callerType\"];\r\n        var callerPage = qrScan[\"callerPage\"];\r\n        var displayQRPage = qrScan[\"displayQRPage\"];\r\n\r\n        var currentPage = \"\";\r\n        if (window.history.state != null) {\r\n            currentPage = window.history.state.pageName;\r\n        }\r\n        // Ckeck if we are running in the context of the page that initiated scanning\r\n        if (currentPage != callerPage) {\r\n            // The user navigated out of the scan page, should stop using the camera\r\n            stopMediaTracks(myStream);\r\n\r\n            // Return without activating the callback again, so it will stop completely\r\n            return;\r\n        }\r\n\r\n        // We have to wait until the video stream is ready\r\n        if (video.readyState !== video.HAVE_ENOUGH_DATA) {\r\n            // We are not yet ready\r\n\r\n            // Request to be called again in next frame\r\n            //      setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n            requestAnimationFrame(ReceiveQRtick);\r\n\r\n\r\n            // Exit from the function until it will be called again\r\n            return;\r\n        }\r\n\r\n        // Video is ready, display canvas\r\n        canvasElement.hidden = false;\r\n\r\n        // Set the canvas size to match the video stream\r\n        canvasElement.height = video.videoHeight;\r\n        canvasElement.width = video.videoWidth;\r\n        //let elwidth = Math.min(screen.availWidth - 60, 350);\r\n        let displayWidth = video.videoWidth\r\n        let displayHeight = video.videoHeight\r\n\r\n        // Get a video frame and decode an image data using the canvas element\r\n        canvas.drawImage(video, 0, 0, displayWidth, displayHeight);\r\n        var imageData = canvas.getImageData(\r\n            0,\r\n            0,\r\n            displayWidth,\r\n            displayHeight\r\n        );\r\n\r\n        try {\r\n            // Try to decode the image as a QR code\r\n            var code = jsQR(imageData.data, imageData.width, imageData.height, {\r\n                inversionAttempts: \"dontInvert\",\r\n            });\r\n        } catch (error) {\r\n            console.error(\"jsQR:\", error)\r\n        }\r\n\r\n        // If unsuccessful, exit requesting to be called again at next animation frame\r\n        if (!code) {\r\n            // Request to be called again in next frame\r\n            //      setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n            requestAnimationFrame(ReceiveQRtick);\r\n\r\n            // Exit from the function\r\n            return;\r\n        }\r\n\r\n        // If we reached up to here, we have a valid QR\r\n\r\n        // Try to detect the type of data received\r\n        var qrType = detectQRtype(code.data);\r\n        if (qrType == \"unknown\") {\r\n            // We do not know what type it is. Continue scanning\r\n\r\n            // Request to be called again in next frame\r\n            //      setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n            requestAnimationFrame(ReceiveQRtick);\r\n\r\n            // Exit from the function\r\n            return;\r\n        }\r\n\r\n        if (qrType == \"MultiJWT\") {\r\n            mylog(\"Scanned MultiJWT QR\");\r\n            // We are going to receive a series of QRs and then join the pieces together\r\n            // Each piece has the format: \"xx|yy|data\" where\r\n            //   xx is the total number of pieces to receive, expressed as two decimal digits\r\n            //   yy is the index of this piece in the whole data, expressed as two decimal digits\r\n            //   data is the actual data of the piece\r\n\r\n            // Split the data in the QR in the components\r\n            var components = code.data.split(\"|\");\r\n\r\n            // The first and second components are \"multi\" and \"w3cvc\" and we do not need them\r\n\r\n            // The third component is the total number of pieces to receive\r\n            var total = components[2];\r\n\r\n            // The fourth is the index of the received component\r\n            var index = components[3];\r\n\r\n            // And the fifth is the actual piece of data\r\n            var piece = components[4];\r\n\r\n            // Check if we received two integers each with two digits, from \"00\" to \"99\"\r\n            // ASCII code for \"0\" is 48 and for \"9\" is 57\r\n            var total1 = total.charCodeAt(0);\r\n            var total2 = total.charCodeAt(1);\r\n            var index1 = index.charCodeAt(0);\r\n            var index2 = index.charCodeAt(1);\r\n            if (\r\n                total1 < 48 ||\r\n                total1 > 57 ||\r\n                total2 < 48 ||\r\n                total2 > 57 ||\r\n                index1 < 48 ||\r\n                index1 > 57 ||\r\n                index2 < 48 ||\r\n                index2 > 57\r\n            ) {\r\n                // Invalid data received, keep trying\r\n                // Request to be called again in next frame\r\n                //        setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n                requestAnimationFrame(ReceiveQRtick);\r\n\r\n                // Exit from the function\r\n                return;\r\n            }\r\n\r\n            // Check if we already received this piece\r\n            if (receivedPieces.has(index)) {\r\n                // Already received, continue scanning\r\n\r\n                // Request to be called again in next frame\r\n                //        setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n                requestAnimationFrame(ReceiveQRtick);\r\n\r\n                // Exit from the function\r\n                return;\r\n            }\r\n\r\n            // This is a new piece. Add it to the set\r\n            receivedPieces.add(index);\r\n            receivedQRPieces[+index] = piece; // Make sure that index is considered an integer and not a string\r\n\r\n            // Display in the page the number of the object received.\r\n            progressMessages.innerText = \"Received piece: \" + index;\r\n\r\n            // Check if we need more pieces\r\n            if (receivedPieces.size < total) {\r\n                // Continue scanning\r\n\r\n                // Request to be called again in next frame\r\n                //        setTimeout(ReceiveQRtick, scanRefreshInterval);\r\n                requestAnimationFrame(ReceiveQRtick);\r\n\r\n                // Exit from the function\r\n                return;\r\n            }\r\n\r\n            // We have received all pieces\r\n\r\n            // Stop the media stream\r\n            stopMediaTracks(myStream);\r\n\r\n            // Hide the picture\r\n            canvasElement.hidden = true;\r\n\r\n            mylog(\"Received all pieces\", receivedQRPieces);\r\n\r\n            // Assemble all pieces together\r\n            var jwt = receivedQRPieces.join(\"\");\r\n            mylog(\"Received jwt\", jwt);\r\n\r\n            // Extract the credential and save in the temporary storage\r\n            try {\r\n                var cred = decodeJWT(jwt);\r\n\r\n                // Store in temporal storage so the page will retrieve it\r\n                let currentCredential = {\r\n                    type: \"w3cvc\",\r\n                    encoded: jwt,\r\n                    decoded: cred,\r\n                };\r\n                mylog(\"Writing current cred: \", currentCredential);\r\n                await settingsPut(\"currentCredential\", currentCredential);\r\n            } catch (error) {\r\n                myerror(error);\r\n                progressMessages.innerText = error;\r\n                return;\r\n            }\r\n\r\n            // Switch to the presentation of results\r\n            gotoPage(displayQRPage, { screenType: callerType });\r\n\r\n            return;\r\n        }\r\n\r\n        if (qrType == \"URL\") {\r\n            // We received a URL in the QR. Perform a GET to obtain the JWT from a server\r\n            mylog(\"Scanned normal URL QR\");\r\n\r\n            // Stop the media stream\r\n            stopMediaTracks(myStream);\r\n\r\n            // Build the URL to call\r\n            let targetURLRead = code.data.trim();\r\n\r\n            // Check if the URL points to a JWT or to the wallet\r\n            if (targetURLRead.startsWith(MYSELF)) {\r\n                // The URL points to the wallet. There is a param with the credential id\r\n                const url = new URL(targetURLRead);\r\n\r\n                // First we check for a normal credential\r\n                let credId = url.searchParams.get(\"id\");\r\n                if (credId) {\r\n                    targetURLRead = ISSUER_GET_CREDENTIAL + credId;\r\n                } else {\r\n                    // Now check for a Public Credential\r\n                    credId = url.searchParams.get(\"pubid\");\r\n                    if (credId) {\r\n                        targetURLRead = ISSUER_GET_PUBLIC_CREDENTIAL + credId;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Retrieve the credential from the server and display it\r\n            await requestQRAndDisplay(targetURLRead, displayQRPage, callerType);\r\n\r\n            return;\r\n        }\r\n\r\n        const HC_ISS = 1;\r\n        const HC_IAT = 6;\r\n        const HC_EXP = 4;\r\n        const HC_CTI = 7;\r\n        const HC_HCERT = -260;\r\n\r\n        if (qrType == \"HC1\") {\r\n            // We received a Health Certificate (HC) version 1 encoded QR.\r\n            mylog(\"Scanned HC1 QR\");\r\n\r\n            let plain = await CWT.decodeHC1QR(code.data);\r\n            console.log(\"CWT.decodeHC1QR\", plain)\r\n\r\n            // Store in temporal storage so the page will retrieve it\r\n            let currentCredential = {\r\n                type: \"hcert\",\r\n                encoded: code.data,\r\n                decoded: plain,\r\n            };\r\n            await settingsPut(\"currentCredential\", currentCredential);\r\n\r\n            // Stop the media stream\r\n            stopMediaTracks(myStream);\r\n\r\n            // Switch to the presentation of results\r\n            gotoPage(displayQRPage, { screenType: callerType });\r\n\r\n            return;\r\n        }\r\n\r\n        if (qrType == \"Base64\") {\r\n            // We received a Base64 encoded QR. May be it is the UK Immigration document\r\n            mylog(\"Scanned Base64 simple QR\");\r\n\r\n            let decodedQR = JSON.parse(atobUrl(code.data));\r\n\r\n            // Store in temporal storage so the page will retrieve it\r\n            let currentCredential = {\r\n                type: \"ukimmigration\",\r\n                encoded: code.data,\r\n                decoded: decodedQR,\r\n            };\r\n            await settingsPut.setItem(\"currentCredential\", currentCredential);\r\n\r\n            // Stop the media stream\r\n            stopMediaTracks(myStream);\r\n\r\n            // Switch to the presentation of results\r\n            gotoPage(displayQRPage, { screenType: callerType });\r\n\r\n            return;\r\n        }\r\n    } catch (error) {\r\n\r\n        // Stop the media stream\r\n        stopMediaTracks(myStream);\r\n\r\n        console.error(error)\r\n        alert(`Error: ${error}`)\r\n\r\n        // Go to the home page to start again\r\n        gotoPage(homePage);\r\n\r\n        // Exit from the function\r\n        return;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}